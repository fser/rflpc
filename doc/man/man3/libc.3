.TH "LIBC tiny subset" 3 "Wed Mar 21 2012" "rfLPC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LIBC tiny subset \- 
.PP
The rflpc library implement a very small subset of the libc\&.  

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBprintf\fP (const char *format,\&.\&.\&.)"
.br
.RI "\fIFormated output function\&. \fP"
.ti -1c
.RI "void \fBrflpc_printf_set_putchar\fP (int(*putchar_func)(int c))"
.br
.RI "\fISets the internal function pointer that is used by \fBprintf\fP to output a character\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "void * \fBmemcpy\fP (void *dest, const void *src, size_t n)"
.br
.RI "\fICopies memory from one buffer to another\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "void * \fBmemset\fP (void *dest, int c, size_t n)"
.br
.RI "\fIFills the first n bytes of the memory area pointed to by dest with the constant byte c\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The rflpc library implement a very small subset of the libc\&. 
.SH "Function Documentation"
.PP 
.SS "void* \fBmemcpy\fP (void *dest, const void *src, size_tn)"

.PP
Copies memory from one buffer to another\&. \fBNote:\fP
.RS 4
if the src and dest are aligned on 4 bytes, copy is done by 4 bytes block, so it should be faster if the given pointers are aligned on a 4 byte boundary 
.RE
.PP
\fBWarning:\fP
.RS 4
dest and src should not overlap\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP destination buffer 
.br
\fIsrc\fP source buffer 
.br
\fIn\fP number of bytes to copy
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "void* \fBmemset\fP (void *dest, intc, size_tn)"

.PP
Fills the first n bytes of the memory area pointed to by dest with the constant byte c\&. \fBNote:\fP
.RS 4
if the src and dest are aligned on 4 bytes, memset is done by 4 bytes block, so it should be faster if the given pointers are aligned on a 4 byte boundary
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP destination buffer 
.br
\fIc\fP value to set 
.br
\fIn\fP number of bytes to copy
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "int \fBprintf\fP (const char *format, \&.\&.\&.)"

.PP
Formated output function\&. This function is similar to stdio's printf\&. However, it only handles:
.IP "\(bu" 2
%d
.IP "\(bu" 2
%x/X (%0?X can also be used, where ? is a digit [1-9])
.IP "\(bu" 2
%p
.IP "\(bu" 2
%c
.IP "\(bu" 2
%s
.PP
.PP
\fBNote:\fP
.RS 4
If another format char is used, int is assumed to skip argument, but nothing is printed unless RFLPC_VERBOSE_PRINTF is defined when compiling lib\&. If RFLPC_CONFIG_ENABLE_ATOMIC_PRINTF is defined, interrupts are disabled when entering printf and enabled before exiting
.RE
.PP
\fBWarning:\fP
.RS 4
This function uses a function pointer to output each character\&. By default, it uses a function which eventually call \fBrflpc_uart_putchar\fP with \fBRFLPC_UART0\fP\&. If you want to use your own putchar function, you have to call \fBrflpc_printf_set_putchar\fP to set the function pointer\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIformat\fP The format string\&. Prefer to use constant string instead of user supplied string to be sure that some escape characters are not put for wrong purpose\&. 
.RE
.PP

.SS "void \fBrflpc_printf_set_putchar\fP (int(*)(int c)putchar_func)"

.PP
Sets the internal function pointer that is used by \fBprintf\fP to output a character\&. By default, it uses a function that call \fBrflpc_uart_putchar\fP with \fBRFLPC_UART0\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIputchar_func\fP a pointer to a function that takes a character to put and returns it\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for rfLPC from the source code\&.
