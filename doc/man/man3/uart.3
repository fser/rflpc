.TH "UART" 3 "Wed Mar 21 2012" "rfLPC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
UART \- 
.PP
This is the driver for the UART0/2/3\&.  

.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBrflpc_uart_t\fP { \fBRFLPC_UART0\fP =  0, \fBRFLPC_UART2\fP =  2, \fBRFLPC_UART3\fP =  3 }"
.br
.RI "\fIConstants that represents the UART port you want to use in uart driver functions\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBrflpc_uart_init\fP (\fBrflpc_uart_t\fP uart_num)"
.br
.RI "\fIInits the UART e, using 11520 baud, 8 bits data, no parity and 1 stop bit\&. \fP"
.ti -1c
.RI "void \fBrflpc_uart_putchar\fP (\fBrflpc_uart_t\fP uart_num, char c)"
.br
.RI "\fISends a byte to the uart\&. \fP"
.ti -1c
.RI "int \fBrflpc_uart_byte_available\fP (\fBrflpc_uart_t\fP uart_num)"
.br
.RI "\fITest the reception FIFO\&. \fP"
.ti -1c
.RI "char \fBrflpc_uart_getchar\fP (\fBrflpc_uart_t\fP uart_num)"
.br
.RI "\fIGets a character from the uart\&. \fP"
.ti -1c
.RI "void \fBrflpc_uart_set_rx_callback\fP (\fBrflpc_uart_t\fP uart_num, \fBrflpc_irq_handler_t\fP callback)"
.br
.RI "\fISets the uart rx callback\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This is the driver for the UART0/2/3\&. 

At the moment, this driver is only usable when the CPU is clocked at 96Mhz and the UART mode is set to
.IP "\(bu" 2
115200 bauds
.IP "\(bu" 2
8 bits data
.IP "\(bu" 2
no parity check
.IP "\(bu" 2
1 stop bit 
.PP
\fBTodo\fP
.RS 4
Allow fine configuration for the UART\&. Just have to calculate divider and multiplier depending on cpu clock and desired speed\&.
.RE
.PP

.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBrflpc_uart_t\fP"

.PP
Constants that represents the UART port you want to use in uart driver functions\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIRFLPC_UART0 \fP\fP
Use UART0\&. 
.TP
\fB\fIRFLPC_UART2 \fP\fP
Use UART2\&. 
.TP
\fB\fIRFLPC_UART3 \fP\fP
Use UART3\&. 
.PP
Definition at line 45 of file uart\&.h\&.
.SH "Function Documentation"
.PP 
.SS "int \fBrflpc_uart_byte_available\fP (\fBrflpc_uart_t\fPuart_num)"

.PP
Test the reception FIFO\&. \fBParameters:\fP
.RS 4
\fIuart_num\fP the uart to use 
.RE
.PP
\fBReturns:\fP
.RS 4
true if a byte is available 
.RE
.PP

.SS "char \fBrflpc_uart_getchar\fP (\fBrflpc_uart_t\fPuart_num)"

.PP
Gets a character from the uart\&. \fBParameters:\fP
.RS 4
\fIuart_num\fP the uart to use 
.RE
.PP
\fBReturns:\fP
.RS 4
the character read\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
This function loops while no data is available! 
.RE
.PP

.SS "int \fBrflpc_uart_init\fP (\fBrflpc_uart_t\fPuart_num)"

.PP
Inits the UART e, using 11520 baud, 8 bits data, no parity and 1 stop bit\&. \fBReturns:\fP
.RS 4
0 if init is successful, -1 otherwise 
.RE
.PP
\fBNote:\fP
.RS 4
at the moment, -1 is returned if the CPU is not clocked at 96Mhz 
.RE
.PP

.SS "void \fBrflpc_uart_putchar\fP (\fBrflpc_uart_t\fPuart_num, charc)"

.PP
Sends a byte to the uart\&. \fBParameters:\fP
.RS 4
\fIuart_num\fP the uart to use 
.br
\fIc\fP character to send 
.RE
.PP

.SS "void \fBrflpc_uart_set_rx_callback\fP (\fBrflpc_uart_t\fPuart_num, \fBrflpc_irq_handler_t\fPcallback)"

.PP
Sets the uart rx callback\&. This enables the uart0 interrupt and set the handler accordingly 
.PP
\fBParameters:\fP
.RS 4
\fIuart_num\fP the uart to use 
.br
\fIcallback\fP a pointer to a \fBrflpc_irq_handler_t\fP function 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for rfLPC from the source code\&.
