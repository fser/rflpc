.TH "Ethernet" 3 "Wed Mar 21 2012" "rfLPC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Ethernet \- 
.PP
Most of the defines are directly derived from the user manual of the LPC17xx or the PHY interface datasheet\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBrflpc_eth_descriptor_t\fP"
.br
.RI "\fIThis structure holds a descriptor which describes the fragment received or sent by the ethernet DMA\&. \fP"
.ti -1c
.RI "struct \fBrflpc_eth_rx_status_t\fP"
.br
.RI "\fIThis structure holds the reception status associated to a descriptor\&. \fP"
.ti -1c
.RI "struct \fBrflpc_eth_tx_status_t\fP"
.br
.RI "\fIThis structure holds the transmit status associated to a descriptor\&. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_PCENET_BIT\fP   (1 << 30)"
.br
.RI "\fIBit to set to activate ethernet in PCONP register\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAX_FRAME_LENGTH\fP   1538"
.br
.RI "\fIMaximum size of an ethernet frame Consist of: \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAX_CLOCK\fP   2500000"
.br
.RI "\fIMaximum allowed clock frequency for MII, defined by IEEE 802\&.3, see p\&. \fP"
.ti -1c
.RI "#define \fBTX_PRODUCE_INDEX_INC\fP(inc)   ((LPC_EMAC->TxProduceIndex + (inc))% (LPC_EMAC->TxDescriptorNumber+1))"
.br
.RI "\fIHelper macro for \fBrflpc_eth_get_current_tx_packet_descriptor\fP\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBrflpc_eth_init\fP ()"
.br
.RI "\fIInits the ethernet device\&. \fP"
.ti -1c
.RI "int \fBrflpc_eth_link_state\fP ()"
.br
.RI "\fIReturns the link state\&. \fP"
.ti -1c
.RI "void \fBrflpc_eth_set_link_mode\fP (int mode)"
.br
.RI "\fIForces the MAC and PHY devices to operate on the given mode no matter the capability of the linked partner\&. \fP"
.ti -1c
.RI "int \fBrflpc_eth_link_auto_negociate\fP (int max_desired_mode)"
.br
.RI "\fIForce the physical link to perform auto negociation of mode\&. \fP"
.ti -1c
.RI "int \fBrflpc_eth_get_link_mode\fP ()"
.br
.RI "\fIreturns the current link mode\&. \fP"
.ti -1c
.RI "static uint32_t \fBrflpc_eth_get_packet_size\fP (uint32_t status_info)"
.br
.RI "\fIReturns the size of a packet from the status_info field of a \fBrflpc_eth_tx_status_t\fP or \fBrflpc_eth_rx_status_t\fP\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_set_tx_control_word\fP (uint32_t size_to_send, uint32_t *control, int trigger_it, int last_fragment)"
.br
.RI "\fISets the transmission control word of a \fBrflpc_eth_descriptor_t\fP struct\&. \fP"
.ti -1c
.RI "void \fBrflpc_eth_set_rx_base_addresses\fP (\fBrflpc_eth_descriptor_t\fP *descriptors, \fBrflpc_eth_rx_status_t\fP *status, int count)"
.br
.RI "\fISets rx descriptors and status base address\&. \fP"
.ti -1c
.RI "static int \fBrflpc_eth_get_current_rx_packet_descriptor\fP (\fBrflpc_eth_descriptor_t\fP **descriptor, \fBrflpc_eth_rx_status_t\fP **status)"
.br
.RI "\fIReturns the pointers on the current rx packet descriptor\&. \fP"
.ti -1c
.RI "static int \fBrflpc_eth_rx_available\fP ()"
.br
.RI "\fIReturns true if a packet has been received and not yet processed available\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_done_process_rx_packet\fP ()"
.br
.RI "\fIThis function has to be called when a packet (which descriptor is returned by \fBrflpc_eth_get_current_rx_packet_descriptor\fP) has been processed and can be discarded\&. \fP"
.ti -1c
.RI "void \fBrflpc_eth_set_tx_base_addresses\fP (\fBrflpc_eth_descriptor_t\fP *descriptos, \fBrflpc_eth_tx_status_t\fP *status, int count)"
.br
.RI "\fISets tx descriptors and status base address\&. \fP"
.ti -1c
.RI "static int \fBrflpc_eth_get_current_tx_packet_descriptor\fP (\fBrflpc_eth_descriptor_t\fP **descriptor, \fBrflpc_eth_tx_status_t\fP **status, int idx)"
.br
.RI "\fIreturns the index of the current tx packet descriptor\&. \fP"
.ti -1c
.RI "static int \fBrflpc_eth_get_last_sent_packet_idx\fP ()"
.br
.RI "\fIReturns the index of the last send buffer\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_done_process_tx_packet\fP (int count)"
.br
.RI "\fIWhen the packet has been generated, calling this function will make it owned by the hardware and queued for emission\&. \fP"
.ti -1c
.RI "void \fBrflpc_eth_get_mac_address\fP (uint8_t *addr)"
.br
.RI "\fIreturns the device MAC address \fP"
.ti -1c
.RI "void \fBrflpc_eth_set_mac_address\fP (const uint8_t *addr)"
.br
.RI "\fIsets the device MAC address \fP"
.ti -1c
.RI "static void \fBrflpc_eth_set_irq_handler\fP (\fBrflpc_irq_handler_t\fP c)"
.br
.RI "\fIsets the interrupt handler of the ethernet peripheral \fP"
.ti -1c
.RI "static void \fBrflpc_eth_irq_enable\fP (uint32_t irqs)"
.br
.RI "\fIenable eth interrupts \fP"
.ti -1c
.RI "static void \fBrflpc_eth_irq_disable\fP (uint32_t irqs)"
.br
.RI "\fIdisable eth interrupts This function will remove irq enable bits\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_irq_enable_set\fP (uint32_t irqs)"
.br
.RI "\fIsets the irq enable register This function will disable all irqs and then only enable those given\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_irq_clear\fP (uint32_t irqs)"
.br
.RI "\fIclear given pending interrupts \fP"
.ti -1c
.RI "static uint32_t \fBrflpc_eth_irq_get_status\fP ()"
.br
.RI "\fIgets the interrupt status\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_irq_trigger\fP (uint32_t irqs)"
.br
.RI "\fIForce the generation of the given interrupt\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_activate_rx_filter\fP (int accept_unicast, int accept_multicast, int accept_broadcast)"
.br
.RI "\fIActivate the hardware receive filter\&. \fP"
.ti -1c
.RI "static void \fBrflpc_eth_deactivate_rx_filter\fP ()"
.br
.RI "\fIDeactivates the hardware receive filter\&. \fP"
.ti -1c
.RI "void \fBrflpc_eth_dump_internals\fP ()"
.br
.RI "\fIUse the \fBprintf\fP function to dump the values of the MAC registers\&. \fP"
.in -1c
.SS "Ethernet pin configuration"
This allows the configuration of the pins of the LPC17xx to use the ethernet device\&.
.PP
This values are for LPC17xx devices\&. 
.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_PORT\fP   1"
.br
.RI "\fINumber of the port the eth is connected to\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_TXD0\fP   0"
.br
.RI "\fITransmit data bit 0\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_TXD1\fP   1"
.br
.RI "\fITransmit data bit 1\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_TX_EN\fP   4"
.br
.RI "\fITransmit data enable pin\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_CRS\fP   8"
.br
.RI "\fICarrier sense Pin\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_RXD0\fP   9"
.br
.RI "\fIReceive data bit 0\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_RXD1\fP   10"
.br
.RI "\fIReceive data bit 1\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_RX_ER\fP   14"
.br
.RI "\fIReceive error\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_REF_CLK\fP   15"
.br
.RI "\fIReference clock\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_MDC\fP   16"
.br
.RI "\fIMIIM Clock pin\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_PIN_MDIO\fP   17"
.br
.RI "\fIMI data input and output pin\&. \fP"
.in -1c
.SS "MAC Configuration register bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RECEIVE_ENABLE\fP   (1 << 0)"
.br
.RI "\fIEnable reception\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_PASS_ALL_FRAMES\fP   (1 << 1)"
.br
.RI "\fIPass all frames to driver\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RX_FLOW_CONTROL\fP   (1 << 2)"
.br
.RI "\fIActivate receive path flow control\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_TX_FLOW_CONTROL\fP   (1 << 3)"
.br
.RI "\fIActivate transmit path flow control\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_LOOPBACK\fP   (1 << 4)"
.br
.RI "\fIActivate interface loopback (for testing purpose mainly\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RESET_TX\fP   (1 << 8)"
.br
.RI "\fIReset tranmit path\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RESET_MCS_TX\fP   (1 << 9)"
.br
.RI "\fIReset Transmit MAC Sublayer control logic\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RESET_RX\fP   (1 << 10)"
.br
.RI "\fIReset receive path\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_RESET_MCS_RX\fP   (1 << 11)"
.br
.RI "\fIReset receive MAC Sublayer control logic\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_SIM_RESET\fP   (1 << 14)"
.br
.RI "\fIReset the random number generator in the transmit function\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC1_SOFT_RESET\fP   (1 << 15)"
.br
.RI "\fIReset the MAC device\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_FULL_DUPLEX\fP   (1 << 0)"
.br
.RI "\fIDuplex mode selection\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_FRAME_LENGTH_CHK\fP   (1 << 1)"
.br
.RI "\fICheck lenght of received and transmited frames and report in status info\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_HUGE_FRAME_ENABLE\fP   (1 << 2)"
.br
.RI "\fIActivate jumbo frames\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_DELAYED_CRC\fP   (1 << 3)"
.br
.RI "\fIWait some bytes before begining CRC calculation (if proprietary bytes are sent before 802\&.3 header\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_CRC_ENABLE\fP   (1 << 4)"
.br
.RI "\fIAdd CRC to every frames\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_PAD_CRC_ENABLE\fP   (1 << 5)"
.br
.RI "\fIActivate CRC and/or Padding\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_VLAN_PAD_ENABLE\fP   (1 << 6)"
.br
.RI "\fIActivate padding when sending frame smaller that 64 bytes\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_AUTO_DETECT_PAD_ENABLE\fP   (1 << 7)"
.br
.RI "\fIAuto detect padded frames\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_PURE_PREAMBLE_ENFORCE\fP   (1 << 8)"
.br
.RI "\fIForce verification of preamble\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_LONG_PREAMBLE_ENFORCE\fP   (1 << 9)"
.br
.RI "\fIForce the use of long preamble\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_NO_BACKOFF\fP   (1 << 12)"
.br
.RI "\fIDisable backoff after a collision occur\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_BACK_PRESSURE\fP   (1 << 13)"
.br
.RI "\fIDisable backoff after a collision occur during back pressure\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_MAC2_EXCESS_DEFER\fP   (1 << 14)"
.br
.RI "\fIWhen enabled (set to ’1’) the MAC will defer to carrier indefinitely as per the Standard\&. \fP"
.in -1c
.SS "MAC Control register bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_RX_ENABLE\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_TX_ENABLE\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_REG_RESET\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_TX_RESET\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_RX_RESET\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_PASS_RUNT_FRAMES\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_PASS_RX_FILTER\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_TX_FLOW_CONTROL\fP   (1 << 8)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_RMII\fP   (1 << 9)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_CMD_FULL_DUPLEX\fP   (1 << 10)"
.br
.in -1c
.SS "MAC Filtering register bits (p\&. 166)"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_UNICAST_EN\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_BROADCAST_EN\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_MULTICAST_EN\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_UNICAST_HASH_EN\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_MULTICAST_HASH_EN\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_PERFECT_EN\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_MAGIC_WOL_EN\fP   (1 << 12)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_RXFILTER_RXFILTER_WOL_EN\fP   (1 << 13)"
.br
.in -1c
.SS "MIND control register"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_MIND_BUSY\fP   (1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_MIND_SCANNING\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_MIND_NOT_VALID\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_MIND_MII_LINK_FAIL\fP   (1 << 3)"
.br
.in -1c
.SS "RMII Support register"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_SUPP_10MBPS\fP   (0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_SUPP_100MBPS\fP   (1 << 8)"
.br
.in -1c
.SS "MII control register bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_MCFG_SCAN_INCREMENT\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_MCFG_SUPPRESS_PREAMBLE\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_MCFG_RESET_MIIM\fP   (1 << 15)"
.br
.in -1c
.SS "PHY Registers"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_BMCR\fP   (0x0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_BMSR\fP   (0x1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_PHYIDR1\fP   (0x2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_PHYIDR2\fP   (0x3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_ANAR\fP   (0x4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_ANLPAR\fP   (0x5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_ANLPARNP\fP   (0x5) /* Not a bug, it IS the same addr (p\&. 36 of the DP83848J datasheet */"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_ANER\fP   (0x6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_ANNPTR\fP   (0x7)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_PHYSTS\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_FCSCR\fP   (0x14)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_RECR\fP   (0x15)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_PCSR\fP   (0x16)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_RBR\fP   (0x17)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_LEDCR\fP   (0x18)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_PHYCR\fP   (0x19)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_10BTSCR\fP   (0x1A)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_CDCTRL1\fP   (0x1B)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHY_EDCR\fP   (0x1D)"
.br
.in -1c
.SS "Basic Mode Control Register (BMSR) bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_RESET\fP   (1 << 15)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_LOOPBACK\fP   (1 << 14)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_SPEED_SELECT\fP   (1 << 13)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_ENABLE_AUTO_NEG\fP   (1 << 12)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_POWER_DOWN\fP   (1 << 11)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_ISOLATE\fP   (1 << 10)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_RESTART_AUTO_NEG\fP   (1 << 9)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_DUPLEX_MODE\fP   (1 << 8)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMCR_COLLISION_TEST\fP   (1 << 7)"
.br
.in -1c
.SS "Basic Mode Status Register (BMSR) bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_100BASET4\fP   (1 << 15)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_100BASETX_FULL\fP   (1 << 14)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_100BASETX_HALF\fP   (1 << 13)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_10BASET_FULL\fP   (1 << 12)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_10BASET_HALF\fP   (1 << 11)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_MF_PREAMBLE_SUPPRESSION\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_AUTO_NEG_COMPLETE\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_REMOTE_FAULT\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_CAN_AUTO_NEG\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_LINK_STATUS\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_JABBER_DETECT\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_BMSR_EXT_REGISTER_CAPS\fP   (1 << 0)"
.br
.in -1c
.SS "Auto negotiation advertisement register (ANAR) bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_ASM_DIR\fP   (1 << 11)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_PAUSE\fP   (1 << 10)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_T4\fP   (1 << 9)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_TX_FD\fP   (1 << 8)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_TX\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_10_FD\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_ANAR_10\fP   (1 << 5)"
.br
.in -1c
.SS "PHY status register (PHYSTS) bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_MDI_X\fP   (1 << 14)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_RX_ERROR_LATCH\fP   (1 << 13)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_POLARITY_STATUS\fP   (1 << 12)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_FALSE_CARRIER_SENSE_LATCH\fP   (1 << 11)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_SIGNAL_DETECT\fP   (1 << 10)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_DESCRAMBLER_LOCK\fP   (1 << 9)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_PAGE_RECEIVED\fP   (1 << 8)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_REMOTE_FAULT\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_JABBER_DETECT\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_AUTO_NEG_COMPLETE\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_LOOPBACK_STATUS\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_DUPLEX_STATUS\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_SPEED_STATUS\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_PHYSTS_LINK_STATUS\fP   (1 << 0)"
.br
.in -1c
.SS "Interrupt bits"

.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_RX_OVERRUN\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_RX_ERROR\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_RX_FINISHED\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_RX_DONE\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_TX_UNDERRUN\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_TX_ERROR\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_TX_FINISHED\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_TX_DONE\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_SOFT\fP   (1 << 12)"
.br
.ti -1c
.RI "#define \fBRFLPC_ETH_IRQ_EN_WAKE_UP\fP   (1 << 13)"
.br
.in -1c
.SS "Link modes"
These constants can be used to get or set the link mode using \fBrflpc_eth_get_link_mode\fP and \fBrflpc_eth_set_link_mode\fP\&. 
.in +1c
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_SPEED_BIT\fP   (1 << 0)"
.br
.RI "\fIThis bit indicates 100Mbps/10Mbps speed\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_DUPLEX_BIT\fP   (1 << 1)"
.br
.RI "\fIThis bit indicates Full/Half duplex mode\&. \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_100HD\fP   (\fBRFLPC_ETH_LINK_MODE_SPEED_BIT\fP)"
.br
.RI "\fI100Mbps, Half Duplex \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_10HD\fP   (0)"
.br
.RI "\fI10Mbps, Half Duplex \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_100FD\fP   (\fBRFLPC_ETH_LINK_MODE_SPEED_BIT\fP | \fBRFLPC_ETH_LINK_MODE_DUPLEX_BIT\fP)"
.br
.RI "\fI100Mbps, Full Duplex \fP"
.ti -1c
.RI "#define \fBRFLPC_ETH_LINK_MODE_10FD\fP   (\fBRFLPC_ETH_LINK_MODE_DUPLEX_BIT\fP)"
.br
.RI "\fI10Mbps, Full Duplex \fP"
.in -1c
.SH "Detailed Description"
.PP 
Most of the defines are directly derived from the user manual of the LPC17xx or the PHY interface datasheet\&. 

Please refer to these documentation for further information 
.SH "Define Documentation"
.PP 
.SS "#define \fBRFLPC_ETH_ANAR_ASM_DIR\fP   (1 << 11)"

.PP
Definition at line 277 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_BMCR_RESET\fP   (1 << 15)"

.PP
Definition at line 241 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_BMSR_100BASET4\fP   (1 << 15)"

.PP
Definition at line 256 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_CMD_RX_ENABLE\fP   (1 << 0)"

.PP
Definition at line 138 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_IRQ_EN_RX_OVERRUN\fP   (1 << 0)"

.PP
Definition at line 312 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_MAC2_EXCESS_DEFER\fP   (1 << 14)"

.PP
When enabled (set to ’1’) the MAC will defer to carrier indefinitely as per the Standard\&. When disabled, the MAC will abort when the excessive deferral limit is reached\&. 
.PP
Definition at line 129 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_MAX_CLOCK\fP   2500000"

.PP
Maximum allowed clock frequency for MII, defined by IEEE 802\&.3, see p\&. 154 of the user manual 
.PP
Definition at line 203 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_MAX_FRAME_LENGTH\fP   1538"

.PP
Maximum size of an ethernet frame Consist of: .IP "\(bu" 2
1500 bytes for payload
.IP "\(bu" 2
8 bytes for preamble/sfd
.IP "\(bu" 2
12 bytes for src and dst address
.IP "\(bu" 2
2 bytes for length/type
.IP "\(bu" 2
4 bytes for CRC
.IP "\(bu" 2
12 bytes for minimum interframe gap 
.PP

.PP
Definition at line 201 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_MCFG_SCAN_INCREMENT\fP   (1 << 0)"

.PP
Definition at line 187 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_MIND_BUSY\fP   (1)"

.PP
Definition at line 169 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_PHY_BMCR\fP   (0x0)"

.PP
Definition at line 211 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_PHYSTS_MDI_X\fP   (1 << 14)"

.PP
Definition at line 290 of file eth_const\&.h\&.
.SS "#define \fBRFLPC_ETH_RXFILTER_UNICAST_EN\fP   (1 << 0)"

.PP
Definition at line 154 of file eth_const\&.h\&.
.PP
Referenced by rflpc_eth_activate_rx_filter()\&.
.SS "#define \fBRFLPC_ETH_SUPP_10MBPS\fP   (0)"

.PP
Definition at line 179 of file eth_const\&.h\&.
.SH "Function Documentation"
.PP 
.SS "static void \fBrflpc_eth_activate_rx_filter\fP (intaccept_unicast, intaccept_multicast, intaccept_broadcast)\fC [inline, static]\fP"

.PP
Activate the hardware receive filter\&. When activated, the hardware will discard all packet whose destination address are not for the device (MAC address filter)\&.
.PP
\fBParameters:\fP
.RS 4
\fIaccept_unicast\fP If true, accept ALL unicast frames 
.br
\fIaccept_multicast\fP If true, also accept multicast frames 
.br
\fIaccept_broadcast\fP If true, also accept broadcast frames 
.RE
.PP

.PP
Definition at line 398 of file ethernet\&.h\&.
.PP
References RFLPC_ETH_RXFILTER_UNICAST_EN\&.
.SS "static void \fBrflpc_eth_deactivate_rx_filter\fP ()\fC [inline, static]\fP"

.PP
Deactivates the hardware receive filter\&. All received frames will now be received by the driver\&. 
.PP
Definition at line 415 of file ethernet\&.h\&.
.SS "static void \fBrflpc_eth_done_process_tx_packet\fP (intcount)\fC [inline, static]\fP"

.PP
When the packet has been generated, calling this function will make it owned by the hardware and queued for emission\&. \fBParameters:\fP
.RS 4
\fIcount\fP The number of descriptors to hand to the hardware 
.RE
.PP

.PP
Definition at line 304 of file ethernet\&.h\&.
.PP
References TX_PRODUCE_INDEX_INC\&.
.SS "void \fBrflpc_eth_dump_internals\fP ()"

.PP
Use the \fBprintf\fP function to dump the values of the MAC registers\&. \fBReturns:\fP
.RS 4
void 
.RE
.PP

.SS "static int \fBrflpc_eth_get_current_rx_packet_descriptor\fP (\fBrflpc_eth_descriptor_t\fP **descriptor, \fBrflpc_eth_rx_status_t\fP **status)\fC [inline, static]\fP"

.PP
Returns the pointers on the current rx packet descriptor\&. The returned descriptor is the one of the last received packet that has not been marked as processed by \fBrflpc_eth_done_process_rx_packet()\fP; 
.PP
\fBReturns:\fP
.RS 4
0 if receive queue is empty, 1 if pointers are valid 
.RE
.PP

.PP
Definition at line 212 of file ethernet\&.h\&.
.SS "static int \fBrflpc_eth_get_current_tx_packet_descriptor\fP (\fBrflpc_eth_descriptor_t\fP **descriptor, \fBrflpc_eth_tx_status_t\fP **status, intidx)\fC [inline, static]\fP"

.PP
returns the index of the current tx packet descriptor\&. \fBParameters:\fP
.RS 4
\fIdescriptor\fP a pointer to a pointer of \fBrflpc_eth_descriptor_t\fP 
.br
\fIstatus\fP a pointer to a pointer of \fBrflpc_eth_tx_status_t\fP 
.br
\fIidx\fP the descriptor to get\&. 0 is the first free, 1 the second free\&.\&.\&.
.RE
.PP
The return descriptor is the one that is prepared by software before sending it\&. When \fBrflpc_eth_done_process_tx_packet()\fP is called, the packet will be owned by the hardware and sent as soon as possible\&.
.PP
\fBReturns:\fP
.RS 4
0 if no more descriptor are available (which means that all the buffers are owned by the hardware and waiting to be sent)\&. 1 if pointers are valid 
.RE
.PP

.PP
Definition at line 274 of file ethernet\&.h\&.
.PP
References TX_PRODUCE_INDEX_INC\&.
.SS "static int \fBrflpc_eth_get_last_sent_packet_idx\fP ()\fC [inline, static]\fP"

.PP
Returns the index of the last send buffer\&. \fBReturns:\fP
.RS 4
int 
.RE
.PP

.PP
Definition at line 292 of file ethernet\&.h\&.
.SS "int \fBrflpc_eth_get_link_mode\fP ()"

.PP
returns the current link mode\&. The information is extracted from the PHY PHYSTS register if \fBRFLPC_ETH_USE_EXTENDED_MII\fP is defined\&. Otherwise, it uses the Control register which is less reliable and may return wrong mode (especially for the duplex mode)
.PP
\fBReturns:\fP
.RS 4
bit 0 tells speed, bit 1 tells duplex 
.RE
.PP

.SS "static uint32_t \fBrflpc_eth_get_packet_size\fP (uint32_tstatus_info)\fC [inline, static]\fP"

.PP
Returns the size of a packet from the status_info field of a \fBrflpc_eth_tx_status_t\fP or \fBrflpc_eth_rx_status_t\fP\&. \fBParameters:\fP
.RS 4
\fIstatus_info\fP The corresponding field in \fBrflpc_eth_tx_status_t\fP or \fBrflpc_eth_tx_status_t\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The size of the corresponding buffer 
.RE
.PP

.PP
Definition at line 181 of file ethernet\&.h\&.
.SS "static void \fBrflpc_eth_irq_disable\fP (uint32_tirqs)\fC [inline, static]\fP"

.PP
disable eth interrupts This function will remove irq enable bits\&. \fBParameters:\fP
.RS 4
\fIirqs\fP a bitwise ORed combination of RFLPC_ETH_IRQ_EN_* bits 
.RE
.PP

.PP
Definition at line 347 of file ethernet\&.h\&.
.SS "static void \fBrflpc_eth_irq_enable\fP (uint32_tirqs)\fC [inline, static]\fP"

.PP
enable eth interrupts This function will ADD new irq enable, not set all enable irqs to the ones given\&.
.PP
\fBParameters:\fP
.RS 4
\fIirqs\fP a bitwise ORed combination of RFLPC_ETH_IRQ_EN_* bits 
.RE
.PP

.PP
Definition at line 337 of file ethernet\&.h\&.
.SS "static void \fBrflpc_eth_irq_enable_set\fP (uint32_tirqs)\fC [inline, static]\fP"

.PP
sets the irq enable register This function will disable all irqs and then only enable those given\&. \fBParameters:\fP
.RS 4
\fIirqs\fP a bitwise ORed combination of RFLPC_ETH_IRQ_EN_* bits 
.RE
.PP

.PP
Definition at line 357 of file ethernet\&.h\&.
.SS "static uint32_t \fBrflpc_eth_irq_get_status\fP ()\fC [inline, static]\fP"

.PP
gets the interrupt status\&. \fBReturns:\fP
.RS 4
a bitwise ORed of eth pending interrupt bits 
.RE
.PP

.PP
Definition at line 371 of file ethernet\&.h\&.
.SS "static void \fBrflpc_eth_irq_trigger\fP (uint32_tirqs)\fC [inline, static]\fP"

.PP
Force the generation of the given interrupt\&. This can be used for triggering an interrupt by software
.PP
\fBParameters:\fP
.RS 4
\fIirqs\fP a bitwise ORed combination of RFLPC_ETH_IRQ_EN_* bits 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Definition at line 383 of file ethernet\&.h\&.
.SS "int \fBrflpc_eth_link_auto_negociate\fP (intmax_desired_mode)"

.PP
Force the physical link to perform auto negociation of mode\&. This function will start autonegociation, wait for it to finish and reconfigure MAC/PHY if needed (100Mbps/10Mbps, half duplex/full duplex\&.\&.\&.) 
.PP
\fBParameters:\fP
.RS 4
\fImax_desired_mode\fP bit 0 tells speed, bit 1 tells duplex
.RE
.PP
\fBReturns:\fP
.RS 4
0 if auto-negociation performed successfully\&. -1 otherwise\&. If the link is down when calling this function, -1 will be returned immediatly\&.
.RE
.PP
\fBWarning:\fP
.RS 4
This function is blocking and wait for the autonegociation to be complete\&. 
.RE
.PP

.SS "int \fBrflpc_eth_link_state\fP ()"

.PP
Returns the link state\&. \fBReturns:\fP
.RS 4
true if link is up, false if link is down 
.RE
.PP

.SS "static int \fBrflpc_eth_rx_available\fP ()\fC [inline, static]\fP"

.PP
Returns true if a packet has been received and not yet processed available\&. \fBReturns:\fP
.RS 4
true if a packet is available 
.RE
.PP

.PP
Definition at line 227 of file ethernet\&.h\&.
.SS "void \fBrflpc_eth_set_link_mode\fP (intmode)"

.PP
Forces the MAC and PHY devices to operate on the given mode no matter the capability of the linked partner\&. \fBWarning:\fP
.RS 4
According to PHY datasheet, when forcing the device to use full-duplex without using auto-negociation the partner would not be able to detect full-duplex and thus will use half-duplex\&. So it is always better to use autonegociation\&. Verify which parameter is effectively set with \fBrflpc_eth_get_link_mode\fP 
.RE
.PP

.SS "void \fBrflpc_eth_set_rx_base_addresses\fP (\fBrflpc_eth_descriptor_t\fP *descriptors, \fBrflpc_eth_rx_status_t\fP *status, intcount)"

.PP
Sets rx descriptors and status base address\&. \fBWarning:\fP
.RS 4
descriptors must be aligned on a word boundary\&. status must be aligned on a double word boundaryx 
.RE
.PP

.SS "void \fBrflpc_eth_set_tx_base_addresses\fP (\fBrflpc_eth_descriptor_t\fP *descriptos, \fBrflpc_eth_tx_status_t\fP *status, intcount)"

.PP
Sets tx descriptors and status base address\&. \fBWarning:\fP
.RS 4
descriptors and status must be aligned on a word boundary\&. 
.RE
.PP

.SS "static void \fBrflpc_eth_set_tx_control_word\fP (uint32_tsize_to_send, uint32_t *control, inttrigger_it, intlast_fragment)\fC [inline, static]\fP"

.PP
Sets the transmission control word of a \fBrflpc_eth_descriptor_t\fP struct\&. \fBNote:\fP
.RS 4
This function is only a small helper\&. It will set the last frame bit\&. If you want more control, DIY :) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsize_to_send\fP Size of the buffer to send 
.br
\fIcontrol\fP Pointer to the control word to send 
.br
\fItrigger_it\fP Should the transmission of this buffer produce an interrupt 
.br
\fIlast_fragment\fP Is this fragment the last of the frame 
.RE
.PP

.PP
Definition at line 194 of file ethernet\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for rfLPC from the source code\&.
